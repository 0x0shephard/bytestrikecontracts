// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ICollateralVault} from "../src/Interfaces/ICollateralVault.sol";
import {ClearingHouse} from "../src/ClearingHouse.sol";
import {IClearingHouse} from "../src/Interfaces/IClearingHouse.sol";

/**
 * @title OpenTestPosition
 * @notice Deposits collateral and opens a test position
 */
contract OpenTestPosition is Script {
    address constant CLEARING_HOUSE = 0x0BE85ed0948779a01efFB6b017ae87A4E9EB7FD6;
    address constant COLLATERAL_VAULT = 0xfe2c9c2A1f0c700d88C78dCBc2E7bD1a8BB30DF0;
    address constant MOCK_USDC = 0x8C68933688f94BF115ad2F9C8c8e251AE5d4ade7;
    bytes32 constant ETH_PERP_V2 = 0x923fe13dd90eff0f2f8b82db89ef27daef5f899aca7fba59ebb0b01a6343bfb5;

    // Position parameters
    uint128 constant SIZE = 0.01 ether; // 0.01 ETH
    uint256 constant PRICE_LIMIT = 5 ether; // Max $5 slippage
    uint256 constant COLLATERAL_AMOUNT = 100_000 * 1e6; // 100k USDC

    function run() external {
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address trader = vm.addr(deployerPrivateKey);

        console.log("=========================================");
        console.log("  OPEN TEST POSITION");
        console.log("=========================================");
        console.log("");
        console.log("Trader:", trader);
        console.log("Market: ETH-PERP-V2");
        console.log("");

        // Check balances
        uint256 usdcBalance = IERC20(MOCK_USDC).balanceOf(trader);
        uint256 collateralBalance = ICollateralVault(COLLATERAL_VAULT).balanceOf(trader, MOCK_USDC);

        console.log("BEFORE:");
        console.log("  USDC Balance:", usdcBalance);
        console.log("  Collateral:", collateralBalance);
        console.log("");

        vm.startBroadcast(deployerPrivateKey);

        // Step 1: Deposit collateral if needed
        if (collateralBalance < COLLATERAL_AMOUNT) {
            console.log("Step 1: Depositing collateral via ClearingHouse...");
            // CollateralVault transfers FROM user, so approve vault not clearing house
            IERC20(MOCK_USDC).approve(COLLATERAL_VAULT, COLLATERAL_AMOUNT);
            ClearingHouse(CLEARING_HOUSE).deposit(MOCK_USDC, COLLATERAL_AMOUNT);
            console.log("  Deposited:", COLLATERAL_AMOUNT);
            console.log("");
        } else {
            console.log("Step 1: Sufficient collateral already deposited");
            console.log("");
        }

        // Step 2: Open position
        console.log("Step 2: Opening position...");
        console.log("  Size:", SIZE, "wei (0.01 ETH)");
        console.log("  Direction: LONG");
        console.log("  Price Limit: $5.00");
        console.log("");

        try ClearingHouse(CLEARING_HOUSE).openPosition(ETH_PERP_V2, true, SIZE, PRICE_LIMIT) {
            console.log("SUCCESS: Position opened!");
        } catch Error(string memory reason) {
            console.log("FAILED:");
            console.log("  Reason:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("FAILED: Low-level error");
            console.logBytes(lowLevelData);
        }

        vm.stopBroadcast();

        // Check position
        IClearingHouse.PositionView memory position = ClearingHouse(CLEARING_HOUSE).getPosition(trader, ETH_PERP_V2);
        uint256 newCollateral = ICollateralVault(COLLATERAL_VAULT).balanceOf(trader, MOCK_USDC);

        console.log("");
        console.log("AFTER:");
        console.log("  Position Size:", position.size);
        console.log("  Position Margin:", position.margin);
        console.log("  Entry Price:", position.entryPriceX18);
        console.log("  Collateral:", newCollateral);

        console.log("");
        console.log("=========================================");
        console.log("  COMPLETE");
        console.log("=========================================");
    }
}
